apiVersion: v1
kind: ConfigMap
metadata:
  name: moe-router-config
  namespace: cortex-chat
data:
  config.yaml: |
    # MoE Router Configuration
    router:
      port: 8080
      experts:
        - name: general
          endpoint: http://cortex-orchestrator.cortex.svc.cluster.local:8000
          weight: 1.0
          specialization: "general conversation and task routing"
        - name: infrastructure
          endpoint: http://cortex-orchestrator.cortex.svc.cluster.local:8000
          weight: 2.0
          specialization: "kubernetes, deployment, infrastructure management"
        - name: security
          endpoint: http://cortex-orchestrator.cortex.svc.cluster.local:8000
          weight: 2.0
          specialization: "security scanning, vulnerability analysis, compliance"
        - name: automation
          endpoint: http://cortex-orchestrator.cortex.svc.cluster.local:8000
          weight: 1.5
          specialization: "workflow automation, n8n, langflow"

    qdrant:
      host: qdrant.cortex-chat.svc.cluster.local
      port: 6333
      collection: chat_memory

    telemetry:
      enabled: true
      redis_host: redis.cortex-system.svc.cluster.local
      redis_port: 6379
      redis_key_prefix: "moe:telemetry:"
  simple-chat-api.py: |
    #!/usr/bin/env python3
    """
    Cortex Chat API with MCP Tool Integration
    Enables Claude to query infrastructure via MCP servers
    """
    import os
    import json
    import logging
    import requests
    from flask import Flask, request, jsonify
    from anthropic import Anthropic
    from datetime import datetime

    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    logger = logging.getLogger(__name__)

    app = Flask(__name__)

    # Initialize Anthropic client
    anthropic_client = Anthropic(api_key=os.getenv('ANTHROPIC_API_KEY'))

    # MCP Server configuration
    MCP_SERVERS = {
        "cortex-mcp": "http://cortex-mcp-server.cortex-system.svc.cluster.local:3000",
        "proxmox-mcp": "http://proxmox-mcp-server.cortex-system.svc.cluster.local:3000",
        "unifi-mcp": "http://unifi-mcp-server.cortex-system.svc.cluster.local:3000",
        "sandfly-mcp": "http://sandfly-mcp-server.cortex-system.svc.cluster.local:3000",
    }

    # Simple in-memory conversation storage
    conversations = {}

    # Cache for MCP tools (refreshed on startup and periodically)
    mcp_tools_cache = {}
    tool_to_server_map = {}

    def fetch_mcp_tools():
        """Fetch available tools from all MCP servers"""
        global mcp_tools_cache, tool_to_server_map
        all_tools = []
        tool_to_server_map = {}

        for server_name, server_url in MCP_SERVERS.items():
            try:
                resp = requests.post(
                    server_url,
                    json={"jsonrpc": "2.0", "method": "tools/list", "id": 1},
                    timeout=10
                )
                if resp.status_code == 200:
                    data = resp.json()
                    tools = data.get("result", {}).get("tools", [])
                    for tool in tools:
                        tool_name = tool.get("name")
                        # Prefix tool name with server for uniqueness
                        prefixed_name = f"{server_name}__{tool_name}"
                        tool_to_server_map[prefixed_name] = {
                            "server": server_name,
                            "url": server_url,
                            "original_name": tool_name
                        }
                        # Convert to Anthropic tool format
                        all_tools.append({
                            "name": prefixed_name,
                            "description": f"[{server_name}] {tool.get('description', '')}",
                            "input_schema": tool.get("inputSchema", {"type": "object", "properties": {}})
                        })
                    logger.info(f"Loaded {len(tools)} tools from {server_name}")
            except Exception as e:
                logger.error(f"Failed to fetch tools from {server_name}: {e}")

        mcp_tools_cache = all_tools
        logger.info(f"Total MCP tools available: {len(all_tools)}")
        return all_tools

    def call_mcp_tool(tool_name, arguments):
        """Execute a tool call on the appropriate MCP server"""
        if tool_name not in tool_to_server_map:
            return {"error": f"Unknown tool: {tool_name}"}

        tool_info = tool_to_server_map[tool_name]
        server_url = tool_info["url"]
        original_name = tool_info["original_name"]

        try:
            resp = requests.post(
                server_url,
                json={
                    "jsonrpc": "2.0",
                    "method": "tools/call",
                    "params": {
                        "name": original_name,
                        "arguments": arguments
                    },
                    "id": 1
                },
                timeout=60
            )
            if resp.status_code == 200:
                data = resp.json()
                if "error" in data:
                    return {"error": data["error"]}
                result = data.get("result", {})
                # Extract content from MCP response
                if isinstance(result, dict) and "content" in result:
                    content = result["content"]
                    if isinstance(content, list) and len(content) > 0:
                        return content[0].get("text", str(content))
                return result
            else:
                return {"error": f"MCP server returned {resp.status_code}"}
        except requests.exceptions.Timeout:
            return {"error": "MCP tool call timed out"}
        except Exception as e:
            return {"error": str(e)}

    # Initialize tools on startup
    fetch_mcp_tools()

    @app.route('/health', methods=['GET'])
    def health():
        return jsonify({"status": "healthy", "service": "moe-chat-router"}), 200

    @app.route('/api/auth/login', methods=['POST'])
    def login():
        """Auth endpoint"""
        data = request.json or {}
        username = data.get('username', 'user')
        return jsonify({
            "success": True,
            "token": "mock-token-123",
            "username": username,
            "user": {"username": username, "id": "user-1"}
        }), 200

    @app.route('/api/conversations', methods=['GET'])
    def get_conversations():
        """Get all conversations"""
        conv_list = [
            {
                "id": conv_id,
                "title": f"Conversation {conv_id[:30]}..." if len(conv_id) > 30 else f"Conversation {conv_id}",
                "lastMessage": msgs[-1]["content"] if msgs else "No messages",
                "timestamp": "2026-01-19T00:00:00Z",
                "messageCount": len(msgs)
            }
            for conv_id, msgs in conversations.items()
        ]
        return jsonify(conv_list), 200

    @app.route('/api/conversations', methods=['POST'])
    def create_conversation():
        """Create new conversation"""
        conv_id = f"conv-{len(conversations) + 1}"
        conversations[conv_id] = []
        return jsonify({"id": conv_id, "title": f"New Conversation {conv_id}"}), 201

    # System prompt for Cortex assistant
    SYSTEM_PROMPT = """You are Cortex, an AI infrastructure assistant with direct access to MCP (Model Context Protocol) servers that can query real infrastructure data.

    You have tools to interact with:
    - Proxmox: Virtual machines, containers, nodes, storage, cluster status
    - UniFi: Network devices, clients, sites, ISP metrics, SD-WAN
    - Sandfly: Security scans, host analysis, vulnerability results
    - Cortex: Cross-system queries with intelligent routing

    IMPORTANT: When users ask about infrastructure status, actively USE your tools to fetch real data.
    Don't just describe what you could do - actually call the tools and provide real information.

    For general status queries, good starting tools are:
    - cortex-mcp__cortex_get_status: Get overall Cortex system status
    - cortex-mcp__cortex_query: Query any system with natural language
    - proxmox-mcp__list_nodes: Get Proxmox cluster nodes
    - proxmox-mcp__list_vms: List all virtual machines
    - unifi-mcp__get_system_status: Get UniFi network status
    - sandfly-mcp__sandfly_get_results: Get security scan results

    Be concise and present data clearly. Use tables or lists for structured data."""

    @app.route('/api/chat', methods=['POST'])
    def chat():
        """Main chat endpoint with MCP tool support"""
        try:
            data = request.json
            message = data.get('message', '')
            conversation_id = data.get('sessionId', 'default')

            logger.info(f"Chat request: conversation={conversation_id}, message={message[:50]}...")

            # Store user message
            if conversation_id not in conversations:
                conversations[conversation_id] = []
            conversations[conversation_id].append({
                "role": "user",
                "content": message
            })

            # Build conversation history for Claude
            claude_messages = []
            for msg in conversations[conversation_id]:
                claude_messages.append({
                    "role": msg["role"],
                    "content": msg["content"]
                })

            # Get available tools (refresh if empty)
            tools = mcp_tools_cache if mcp_tools_cache else fetch_mcp_tools()

            # Tool use loop - handle multiple tool calls
            max_iterations = 10
            iteration = 0
            tool_calls_made = []

            try:
                while iteration < max_iterations:
                    iteration += 1

                    # Call Claude API with tools
                    response = anthropic_client.messages.create(
                        model="claude-sonnet-4-20250514",
                        max_tokens=4096,
                        system=SYSTEM_PROMPT,
                        messages=claude_messages,
                        tools=tools if tools else None
                    )

                    # Check if Claude wants to use a tool
                    if response.stop_reason == "tool_use":
                        # Process all tool uses in this response
                        tool_results = []
                        assistant_content = []

                        for block in response.content:
                            if block.type == "tool_use":
                                tool_name = block.name
                                tool_input = block.input
                                tool_use_id = block.id

                                logger.info(f"Tool call: {tool_name} with {json.dumps(tool_input)[:100]}...")
                                tool_calls_made.append({"tool": tool_name, "input": tool_input})

                                # Execute the tool
                                result = call_mcp_tool(tool_name, tool_input)
                                result_str = json.dumps(result) if isinstance(result, (dict, list)) else str(result)

                                tool_results.append({
                                    "type": "tool_result",
                                    "tool_use_id": tool_use_id,
                                    "content": result_str[:10000]  # Limit result size
                                })
                                assistant_content.append(block)
                            elif block.type == "text":
                                assistant_content.append(block)

                        # Add assistant message with tool use
                        claude_messages.append({
                            "role": "assistant",
                            "content": assistant_content
                        })

                        # Add tool results
                        claude_messages.append({
                            "role": "user",
                            "content": tool_results
                        })

                    else:
                        # No more tool calls - extract final response
                        assistant_message = ""
                        for block in response.content:
                            if hasattr(block, 'text'):
                                assistant_message += block.text

                        break

                # Determine expert category for UI display
                expert = 'general'
                msg_lower = message.lower()
                if any(kw in msg_lower for kw in ['pod', 'deploy', 'service', 'node', 'kubectl', 'kubernetes', 'k8s', 'cluster']):
                    expert = 'infrastructure'
                elif any(kw in msg_lower for kw in ['security', 'alert', 'sandfly', 'vulnerability', 'scan']):
                    expert = 'security'
                elif any(kw in msg_lower for kw in ['vm', 'proxmox', 'container', 'virtual']):
                    expert = 'virtualization'
                elif any(kw in msg_lower for kw in ['unifi', 'network', 'wifi', 'client', 'device']):
                    expert = 'network'
                elif any(kw in msg_lower for kw in ['n8n', 'workflow', 'automat', 'langflow']):
                    expert = 'automation'

            except Exception as e:
                logger.error(f"Claude API error: {e}")
                assistant_message = f"I'm having trouble connecting to my AI backend. Error: {str(e)}"
                expert = 'general'

            # Store assistant response
            conversations[conversation_id].append({
                "role": "assistant",
                "content": assistant_message
            })

            return jsonify({
                "response": assistant_message,
                "conversation_id": conversation_id,
                "expert": expert,
                "tool_calls": len(tool_calls_made),
                "timestamp": datetime.utcnow().isoformat()
            }), 200

        except Exception as e:
            logger.error(f"Chat error: {e}")
            return jsonify({"error": str(e)}), 500

    @app.route('/api/tools', methods=['GET'])
    def list_tools():
        """List all available MCP tools"""
        tools = mcp_tools_cache if mcp_tools_cache else fetch_mcp_tools()
        return jsonify({
            "tools": [{"name": t["name"], "description": t["description"]} for t in tools],
            "count": len(tools),
            "servers": list(MCP_SERVERS.keys())
        }), 200

    @app.route('/api/tools/refresh', methods=['POST'])
    def refresh_tools():
        """Refresh the MCP tools cache"""
        tools = fetch_mcp_tools()
        return jsonify({
            "message": "Tools refreshed",
            "count": len(tools)
        }), 200

    @app.route('/api/conversations/<conversation_id>', methods=['GET'])
    def get_conversation_detail(conversation_id):
        """Get conversation with messages"""
        if conversation_id not in conversations:
            conversations[conversation_id] = []

        messages = [
            {
                "role": msg["role"],
                "content": msg["content"],
                "timestamp": "2026-01-19T00:00:00Z"
            }
            for msg in conversations[conversation_id]
        ]

        return jsonify({
            "conversation": {
                "id": conversation_id,
                "title": f"Conversation {conversation_id[:30]}..." if len(conversation_id) > 30 else f"Conversation {conversation_id}",
                "timestamp": "2026-01-19T00:00:00Z",
                "messageCount": len(messages),
                "messages": messages
            }
        }), 200

    @app.route('/api/conversations/<conversation_id>/messages', methods=['GET'])
    def get_messages(conversation_id):
        """Get conversation history"""
        if conversation_id not in conversations:
            return jsonify([]), 200

        messages = [
            {
                "role": msg["role"],
                "content": msg["content"],
                "timestamp": "2026-01-19T00:00:00Z"
            }
            for msg in conversations[conversation_id]
        ]
        return jsonify(messages), 200

    @app.route('/api/status', methods=['GET'])
    def get_system_status():
        """Get status of all connected services and MCP servers"""
        import concurrent.futures

        import socket

        def check_service(name, url, timeout=3):
            try:
                resp = requests.get(url, timeout=timeout)
                return {
                    "name": name,
                    "status": "connected" if resp.status_code == 200 else "error",
                    "latency_ms": int(resp.elapsed.total_seconds() * 1000)
                }
            except requests.exceptions.Timeout:
                return {"name": name, "status": "timeout", "latency_ms": None}
            except requests.exceptions.ConnectionError:
                return {"name": name, "status": "disconnected", "latency_ms": None}
            except Exception as e:
                return {"name": name, "status": "error", "error": str(e), "latency_ms": None}

        def check_redis(host, port, timeout=3):
            """Check Redis connectivity using TCP socket"""
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(timeout)
                start = datetime.utcnow()
                sock.connect((host, port))
                latency = int((datetime.utcnow() - start).total_seconds() * 1000)
                # Just check connection - Redis may require auth
                # Connection success means the service is running
                sock.close()
                return {"name": "redis", "status": "connected", "latency_ms": latency}
            except socket.timeout:
                return {"name": "redis", "status": "timeout", "latency_ms": None}
            except Exception as e:
                return {"name": "redis", "status": "disconnected", "error": str(e)[:50], "latency_ms": None}

        # Define services to check (HTTP endpoints)
        services = {
            # MCP Servers
            "cortex-mcp": ("http://cortex-mcp-server.cortex-system.svc.cluster.local:3000/health", "mcp"),
            "sandfly-mcp": ("http://sandfly-mcp-server.cortex-system.svc.cluster.local:3000/health", "mcp"),
            "proxmox-mcp": ("http://proxmox-mcp-server.cortex-system.svc.cluster.local:3000/health", "mcp"),
            "unifi-mcp": ("http://unifi-mcp-server.cortex-system.svc.cluster.local:3000/health", "mcp"),
            # Cortex Fabric
            "fabric-gateway": ("http://fabric-gateway.cortex-system.svc.cluster.local:8080/health", "fabric"),
            # Infrastructure (chat-related services)
            "qdrant": ("http://qdrant.cortex-chat.svc.cluster.local:6333/readyz", "infrastructure"),
        }

        # Check Claude API connectivity
        def check_claude_api():
            try:
                # Quick test call to Claude API
                response = anthropic_client.messages.create(
                    model="claude-3-5-haiku-20241022",
                    max_tokens=5,
                    messages=[{"role": "user", "content": "ping"}]
                )
                return {"name": "claude-api", "status": "connected", "latency_ms": None}
            except Exception as e:
                return {"name": "claude-api", "status": "error", "error": str(e)[:100], "latency_ms": None}

        results = {
            "mcp_servers": [],
            "cortex_fabric": [],
            "infrastructure": [],
            "mcp_call": {"status": "unknown", "last_call": None}
        }

        # Check services in parallel
        with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
            future_to_service = {
                executor.submit(check_service, name, url): (name, category)
                for name, (url, category) in services.items()
            }
            # Also check Claude API and Redis
            claude_future = executor.submit(check_claude_api)
            redis_future = executor.submit(check_redis, "redis.cortex-chat.svc.cluster.local", 6379)

            for future in concurrent.futures.as_completed(future_to_service):
                name, category = future_to_service[future]
                result = future.result()

                if category == "mcp":
                    results["mcp_servers"].append(result)
                elif category == "fabric":
                    results["cortex_fabric"].append(result)
                elif category == "infrastructure":
                    results["infrastructure"].append(result)

            # Add Claude API and Redis results to infrastructure
            results["infrastructure"].append(claude_future.result())
            results["infrastructure"].append(redis_future.result())

        # Determine overall status for each category
        def get_overall_status(items):
            if not items:
                return "unknown"
            statuses = [item["status"] for item in items]
            if all(s == "connected" for s in statuses):
                return "healthy"
            elif any(s == "connected" for s in statuses):
                return "degraded"
            else:
                return "offline"

        results["overall"] = {
            "mcp_servers": get_overall_status(results["mcp_servers"]),
            "cortex_fabric": get_overall_status(results["cortex_fabric"]),
            "infrastructure": get_overall_status(results["infrastructure"])
        }

        results["timestamp"] = datetime.utcnow().isoformat()

        return jsonify(results), 200

    # Service to Kubernetes deployment mapping
    SERVICE_DEPLOYMENTS = {
        # MCP Servers
        "cortex-mcp": {"namespace": "cortex-system", "deployment": "cortex-mcp-server"},
        "sandfly-mcp": {"namespace": "cortex-system", "deployment": "sandfly-mcp-server"},
        "proxmox-mcp": {"namespace": "cortex-system", "deployment": "proxmox-mcp-server"},
        "unifi-mcp": {"namespace": "cortex-system", "deployment": "unifi-mcp-server"},
        # Cortex Fabric
        "fabric-gateway": {"namespace": "cortex-system", "deployment": "fabric-gateway"},
        # Infrastructure (chat-related)
        "qdrant": {"namespace": "cortex-chat", "deployment": "qdrant"},
        "redis": {"namespace": "cortex-chat", "deployment": "redis"},
        # Note: claude-api cannot be restarted - it's an external service
    }

    def restart_deployment(namespace, deployment_name):
        """Restart a deployment using Kubernetes API via HTTP"""
        try:
            # Read service account token
            with open('/var/run/secrets/kubernetes.io/serviceaccount/token', 'r') as f:
                token = f.read().strip()

            # Read CA cert path
            ca_cert = '/var/run/secrets/kubernetes.io/serviceaccount/ca.crt'

            # Kubernetes API server
            api_server = 'https://kubernetes.default.svc'

            # Patch body to trigger rolling restart
            patch_body = {
                "spec": {
                    "template": {
                        "metadata": {
                            "annotations": {
                                "kubectl.kubernetes.io/restartedAt": datetime.utcnow().isoformat()
                            }
                        }
                    }
                }
            }

            url = f"{api_server}/apis/apps/v1/namespaces/{namespace}/deployments/{deployment_name}"

            response = requests.patch(
                url,
                json=patch_body,
                headers={
                    'Authorization': f'Bearer {token}',
                    'Content-Type': 'application/strategic-merge-patch+json'
                },
                verify=ca_cert,
                timeout=10
            )

            if response.status_code in [200, 201]:
                return True, None
            else:
                return False, f"API returned {response.status_code}: {response.text[:200]}"

        except FileNotFoundError:
            return False, "Service account token not found - not running in cluster"
        except Exception as e:
            return False, str(e)

    @app.route('/api/restart', methods=['POST'])
    def restart_services():
        """Restart unhealthy services via Kubernetes API"""
        data = request.json or {}
        services = data.get('services', [])
        restart_all_unhealthy = data.get('restart_all_unhealthy', False)

        # If restart_all_unhealthy, first get status and find unhealthy services
        if restart_all_unhealthy:
            # Get current status
            status_response = get_system_status()
            status_data = status_response[0].get_json()

            services = []
            for category in ['mcp_servers', 'cortex_fabric', 'infrastructure']:
                for item in status_data.get(category, []):
                    if item.get('status') != 'connected':
                        services.append(item.get('name'))

        if not services:
            return jsonify({"message": "No services to restart", "restarted": []}), 200

        results = {"restarted": [], "failed": [], "skipped": []}

        for service_name in services:
            if service_name not in SERVICE_DEPLOYMENTS:
                results["skipped"].append({"name": service_name, "reason": "Unknown service"})
                continue

            deployment_info = SERVICE_DEPLOYMENTS[service_name]
            namespace = deployment_info["namespace"]
            deployment = deployment_info["deployment"]

            success, error = restart_deployment(namespace, deployment)

            if success:
                results["restarted"].append({
                    "name": service_name,
                    "deployment": deployment,
                    "namespace": namespace
                })
                logger.info(f"Restarted {deployment} in {namespace}")
            else:
                results["failed"].append({
                    "name": service_name,
                    "error": error
                })
                logger.error(f"Failed to restart {deployment}: {error}")

        return jsonify(results), 200

    @app.route('/api/restart/<service_name>', methods=['POST'])
    def restart_single_service(service_name):
        """Restart a single service by name"""
        if service_name not in SERVICE_DEPLOYMENTS:
            return jsonify({"error": f"Unknown service: {service_name}"}), 404

        deployment_info = SERVICE_DEPLOYMENTS[service_name]
        namespace = deployment_info["namespace"]
        deployment = deployment_info["deployment"]

        success, error = restart_deployment(namespace, deployment)

        if success:
            return jsonify({
                "restarted": [{
                    "name": service_name,
                    "deployment": deployment,
                    "namespace": namespace
                }],
                "failed": [],
                "skipped": []
            }), 200
        else:
            return jsonify({
                "restarted": [],
                "failed": [{"name": service_name, "error": error}],
                "skipped": []
            }), 500

    if __name__ == '__main__':
        logger.info(f"Starting MoE Chat Router - routing to {ORCHESTRATOR_URL}")
        app.run(host='0.0.0.0', port=8080, debug=True)
  chat-router.py: |
    #!/usr/bin/env python3
    """
    MoE Chat Router - Routes to cortex-orchestrator with MCP server access
    Provides infrastructure management capabilities
    """
    import os
    import json
    import logging
    import requests
    from flask import Flask, request, jsonify
    from anthropic import Anthropic
    from datetime import datetime

    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    logger = logging.getLogger(__name__)

    app = Flask(__name__)

    # Initialize Anthropic client for intent classification
    anthropic_client = Anthropic(api_key=os.getenv('ANTHROPIC_API_KEY'))

    # Expert configuration - all route to cortex-orchestrator
    ORCHESTRATOR_URL = os.getenv('ORCHESTRATOR_URL', 'http://cortex-orchestrator.cortex-system.svc.cluster.local:8080')

    # Simple in-memory conversation storage
    conversations = {}

    @app.route('/health', methods=['GET'])
    def health():
        return jsonify({"status": "healthy", "service": "moe-chat-router"}), 200

    @app.route('/api/auth/login', methods=['POST'])
    def login():
        """Auth endpoint"""
        data = request.json or {}
        username = data.get('username', 'user')
        return jsonify({
            "success": True,
            "token": "mock-token-123",
            "username": username,
            "user": {"username": username, "id": "user-1"}
        }), 200

    @app.route('/api/conversations', methods=['GET'])
    def get_conversations():
        """Get all conversations"""
        conv_list = [
            {
                "id": conv_id,
                "title": f"Conversation {conv_id[:30]}..." if len(conv_id) > 30 else f"Conversation {conv_id}",
                "lastMessage": msgs[-1]["content"] if msgs else "No messages",
                "timestamp": "2026-01-19T00:00:00Z",
                "messageCount": len(msgs)
            }
            for conv_id, msgs in conversations.items()
        ]
        return jsonify(conv_list), 200

    @app.route('/api/conversations', methods=['POST'])
    def create_conversation():
        """Create new conversation"""
        conv_id = f"conv-{len(conversations) + 1}"
        conversations[conv_id] = []
        return jsonify({"id": conv_id, "title": f"New Conversation {conv_id}"}), 201

    @app.route('/api/chat', methods=['POST'])
    def chat():
        """Main chat endpoint - routes to cortex-orchestrator"""
        try:
            data = request.json
            message = data.get('message', '')
            conversation_id = data.get('sessionId', 'default')

            logger.info(f"Chat request: conversation={conversation_id}, message={message[:50]}...")

            # Store user message
            if conversation_id not in conversations:
                conversations[conversation_id] = []
            conversations[conversation_id].append({
                "role": "user",
                "content": message
            })

            # Classify intent
            intent_prompt = f"""Classify this user message into one of these categories:
            - infrastructure: Kubernetes, pods, deployments, nodes, services
            - security: Sandfly alerts, vulnerabilities, security events
            - automation: n8n workflows, task automation
            - general: Everything else

            User message: {message}

            Respond with just the category name."""

            try:
                intent_response = anthropic_client.messages.create(
                    model="claude-3-5-haiku-20241022",
                    max_tokens=10,
                    messages=[{"role": "user", "content": intent_prompt}]
                )
                expert = intent_response.content[0].text.strip().lower()
                if expert not in ['infrastructure', 'security', 'automation', 'general']:
                    expert = 'general'
            except Exception as e:
                logger.error(f"Intent classification error: {e}")
                expert = 'general'

            logger.info(f"Classified as: {expert}")

            # Route to cortex-orchestrator
            try:
                orch_request = {
                    "message": message,
                    "conversation_id": conversation_id,
                    "expert": expert,
                    "history": conversations[conversation_id][:-1]  # Exclude the message we just added
                }

                response = requests.post(
                    f"{ORCHESTRATOR_URL}/chat",
                    json=orch_request,
                    timeout=60
                )

                if response.status_code == 200:
                    assistant_message = response.json().get('response', 'No response from orchestrator')
                else:
                    logger.error(f"Orchestrator returned {response.status_code}: {response.text}")
                    assistant_message = f"The orchestrator is currently unavailable. Status: {response.status_code}"

            except requests.exceptions.Timeout:
                logger.error("Orchestrator timeout")
                assistant_message = "The request timed out. Please try again."
            except Exception as e:
                logger.error(f"Orchestrator routing error: {e}")
                assistant_message = f"Error routing to expert: {str(e)}"

            # Store assistant response
            conversations[conversation_id].append({
                "role": "assistant",
                "content": assistant_message
            })

            return jsonify({
                "response": assistant_message,
                "conversation_id": conversation_id,
                "expert": expert,
                "timestamp": datetime.utcnow().isoformat()
            }), 200

        except Exception as e:
            logger.error(f"Chat error: {e}")
            return jsonify({"error": str(e)}), 500

    @app.route('/api/conversations/<conversation_id>', methods=['GET'])
    def get_conversation(conversation_id):
        """Get conversation with messages"""
        if conversation_id not in conversations:
            conversations[conversation_id] = []

        messages = [
            {
                "role": msg["role"],
                "content": msg["content"],
                "timestamp": "2026-01-19T00:00:00Z"
            }
            for msg in conversations[conversation_id]
        ]

        return jsonify({
            "conversation": {
                "id": conversation_id,
                "title": f"Conversation {conversation_id[:30]}..." if len(conversation_id) > 30 else f"Conversation {conversation_id}",
                "timestamp": "2026-01-19T00:00:00Z",
                "messageCount": len(messages),
                "messages": messages
            }
        }), 200

    @app.route('/api/conversations/<conversation_id>/messages', methods=['GET'])
    def get_messages(conversation_id):
        """Get conversation history"""
        if conversation_id not in conversations:
            return jsonify([]), 200

        messages = [
            {
                "role": msg["role"],
                "content": msg["content"],
                "timestamp": "2026-01-19T00:00:00Z"
            }
            for msg in conversations[conversation_id]
        ]
        return jsonify(messages), 200

    if __name__ == '__main__':
        logger.info(f"Starting MoE Chat Router - routing to {ORCHESTRATOR_URL}")
        app.run(host='0.0.0.0', port=8080, debug=True)
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: moe-router
  namespace: cortex-chat
  labels:
    app: moe-router
spec:
  replicas: 1
  selector:
    matchLabels:
      app: moe-router
  template:
    metadata:
      labels:
        app: moe-router
    spec:
      serviceAccountName: moe-router
      nodeSelector:
        kubernetes.io/hostname: k3s-worker04
      securityContext:
        fsGroup: 1000
        runAsNonRoot: true
        runAsUser: 1000
        seccompProfile:
          type: RuntimeDefault
      containers:
      - name: moe-router
        image: 10.43.170.72:5000/moe-router:latest
        imagePullPolicy: IfNotPresent
        command: ["python", "simple-chat-api.py"]
        ports:
        - containerPort: 8080
          name: http
          protocol: TCP
        env:
        - name: CONFIG_PATH
          value: /config/config.yaml
        - name: ANTHROPIC_API_KEY
          valueFrom:
            secretKeyRef:
              name: cortex-chat-secrets
              key: anthropic-api-key
        volumeMounts:
        - name: config
          mountPath: /config
        - name: code-fix
          mountPath: /app/simple-chat-api.py
          subPath: simple-chat-api.py
        resources:
          requests:
            cpu: 250m
            memory: 256Mi
          limits:
            cpu: 1000m
            memory: 512Mi
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 10
          periodSeconds: 5
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            drop:
            - ALL
          readOnlyRootFilesystem: true
      volumes:
      - name: config
        configMap:
          name: moe-router-config
      - name: code-fix
        configMap:
          name: moe-router-config
---
apiVersion: v1
kind: Service
metadata:
  name: moe-router
  namespace: cortex-chat
  labels:
    app: moe-router
spec:
  type: ClusterIP
  ports:
  - port: 8080
    targetPort: 8080
    protocol: TCP
    name: http
  selector:
    app: moe-router
