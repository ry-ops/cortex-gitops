apiVersion: v1
kind: ConfigMap
metadata:
  name: moe-router-config
  namespace: cortex-chat
data:
  config.yaml: |
    # MoE Router Configuration
    router:
      port: 8080
      experts:
        - name: general
          endpoint: http://cortex-orchestrator.cortex.svc.cluster.local:8000
          weight: 1.0
          specialization: "general conversation and task routing"
        - name: infrastructure
          endpoint: http://cortex-orchestrator.cortex.svc.cluster.local:8000
          weight: 2.0
          specialization: "kubernetes, deployment, infrastructure management"
        - name: security
          endpoint: http://cortex-orchestrator.cortex.svc.cluster.local:8000
          weight: 2.0
          specialization: "security scanning, vulnerability analysis, compliance"
        - name: automation
          endpoint: http://cortex-orchestrator.cortex.svc.cluster.local:8000
          weight: 1.5
          specialization: "workflow automation, n8n, langflow"

    qdrant:
      host: qdrant.cortex-chat.svc.cluster.local
      port: 6333
      collection: chat_memory

    telemetry:
      enabled: true
      redis_host: redis.cortex-system.svc.cluster.local
      redis_port: 6379
      redis_key_prefix: "moe:telemetry:"
  simple-chat-api.py: |
    #!/usr/bin/env python3
    """
    Simple Chat API that routes to cortex-orchestrator
    """
    import os
    import json
    import logging
    import requests
    from flask import Flask, request, jsonify
    from anthropic import Anthropic
    from datetime import datetime

    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    logger = logging.getLogger(__name__)

    app = Flask(__name__)

    # Initialize Anthropic client for intent classification
    anthropic_client = Anthropic(api_key=os.getenv('ANTHROPIC_API_KEY'))

    # Orchestrator configuration
    ORCHESTRATOR_URL = os.getenv('ORCHESTRATOR_URL', 'http://cortex-orchestrator.cortex-system.svc.cluster.local:8080')

    # Simple in-memory conversation storage
    conversations = {}

    @app.route('/health', methods=['GET'])
    def health():
        return jsonify({"status": "healthy", "service": "moe-chat-router"}), 200

    @app.route('/api/auth/login', methods=['POST'])
    def login():
        """Auth endpoint"""
        data = request.json or {}
        username = data.get('username', 'user')
        return jsonify({
            "success": True,
            "token": "mock-token-123",
            "username": username,
            "user": {"username": username, "id": "user-1"}
        }), 200

    @app.route('/api/conversations', methods=['GET'])
    def get_conversations():
        """Get all conversations"""
        conv_list = [
            {
                "id": conv_id,
                "title": f"Conversation {conv_id[:30]}..." if len(conv_id) > 30 else f"Conversation {conv_id}",
                "lastMessage": msgs[-1]["content"] if msgs else "No messages",
                "timestamp": "2026-01-19T00:00:00Z",
                "messageCount": len(msgs)
            }
            for conv_id, msgs in conversations.items()
        ]
        return jsonify(conv_list), 200

    @app.route('/api/conversations', methods=['POST'])
    def create_conversation():
        """Create new conversation"""
        conv_id = f"conv-{len(conversations) + 1}"
        conversations[conv_id] = []
        return jsonify({"id": conv_id, "title": f"New Conversation {conv_id}"}), 201

    @app.route('/api/chat', methods=['POST'])
    def chat():
        """Main chat endpoint - routes to cortex-orchestrator"""
        try:
            data = request.json
            message = data.get('message', '')
            conversation_id = data.get('sessionId', 'default')

            logger.info(f"Chat request: conversation={conversation_id}, message={message[:50]}...")

            # Store user message
            if conversation_id not in conversations:
                conversations[conversation_id] = []
            conversations[conversation_id].append({
                "role": "user",
                "content": message
            })

            # Classify intent
            intent_prompt = f"""Classify this user message into one of these categories:
            - infrastructure: Kubernetes, pods, deployments, nodes, services
            - security: Sandfly alerts, vulnerabilities, security events
            - automation: n8n workflows, task automation
            - general: Everything else

            User message: {message}

            Respond with just the category name."""

            try:
                intent_response = anthropic_client.messages.create(
                    model="claude-3-5-haiku-20241022",
                    max_tokens=10,
                    messages=[{"role": "user", "content": intent_prompt}]
                )
                expert = intent_response.content[0].text.strip().lower()
                if expert not in ['infrastructure', 'security', 'automation', 'general']:
                    expert = 'general'
            except Exception as e:
                logger.error(f"Intent classification error: {e}")
                expert = 'general'

            logger.info(f"Classified as: {expert}")

            # Route to cortex-orchestrator
            try:
                orch_request = {
                    "message": message,
                    "conversation_id": conversation_id,
                    "expert": expert,
                    "history": conversations[conversation_id][:-1]
                }

                response = requests.post(
                    f"{ORCHESTRATOR_URL}/chat",
                    json=orch_request,
                    timeout=60
                )

                if response.status_code == 200:
                    assistant_message = response.json().get('response', 'No response from orchestrator')
                else:
                    logger.error(f"Orchestrator returned {response.status_code}: {response.text}")
                    assistant_message = f"The orchestrator is currently unavailable. Status: {response.status_code}"

            except requests.exceptions.Timeout:
                logger.error("Orchestrator timeout")
                assistant_message = "The request timed out. Please try again."
            except Exception as e:
                logger.error(f"Orchestrator routing error: {e}")
                assistant_message = f"Error routing to expert: {str(e)}"

            # Store assistant response
            conversations[conversation_id].append({
                "role": "assistant",
                "content": assistant_message
            })

            return jsonify({
                "response": assistant_message,
                "conversation_id": conversation_id,
                "expert": expert,
                "timestamp": datetime.utcnow().isoformat()
            }), 200

        except Exception as e:
            logger.error(f"Chat error: {e}")
            return jsonify({"error": str(e)}), 500

    @app.route('/api/conversations/<conversation_id>', methods=['GET'])
    def get_conversation(conversation_id):
        """Get conversation with messages"""
        if conversation_id not in conversations:
            conversations[conversation_id] = []

        messages = [
            {
                "role": msg["role"],
                "content": msg["content"],
                "timestamp": "2026-01-19T00:00:00Z"
            }
            for msg in conversations[conversation_id]
        ]

        return jsonify({
            "conversation": {
                "id": conversation_id,
                "title": f"Conversation {conversation_id[:30]}..." if len(conversation_id) > 30 else f"Conversation {conversation_id}",
                "timestamp": "2026-01-19T00:00:00Z",
                "messageCount": len(messages),
                "messages": messages
            }
        }), 200

    @app.route('/api/conversations/<conversation_id>/messages', methods=['GET'])
    def get_messages(conversation_id):
        """Get conversation history"""
        if conversation_id not in conversations:
            return jsonify([]), 200

        messages = [
            {
                "role": msg["role"],
                "content": msg["content"],
                "timestamp": "2026-01-19T00:00:00Z"
            }
            for msg in conversations[conversation_id]
        ]
        return jsonify(messages), 200

    @app.route('/api/status', methods=['GET'])
    def get_system_status():
        """Get status of all connected services and MCP servers"""
        import concurrent.futures

        def check_service(name, url, timeout=3):
            try:
                resp = requests.get(url, timeout=timeout)
                return {
                    "name": name,
                    "status": "connected" if resp.status_code == 200 else "error",
                    "latency_ms": int(resp.elapsed.total_seconds() * 1000)
                }
            except requests.exceptions.Timeout:
                return {"name": name, "status": "timeout", "latency_ms": None}
            except requests.exceptions.ConnectionError:
                return {"name": name, "status": "disconnected", "latency_ms": None}
            except Exception as e:
                return {"name": name, "status": "error", "error": str(e), "latency_ms": None}

        # Define services to check
        services = {
            # MCP Servers
            "cortex-mcp": ("http://cortex-mcp.cortex-system.svc.cluster.local:3000/health", "mcp"),
            "sandfly-mcp": ("http://sandfly-mcp-server.cortex-security.svc.cluster.local:3000/health", "mcp"),
            "proxmox-mcp": ("http://proxmox-mcp.cortex-system.svc.cluster.local:3000/health", "mcp"),
            "unifi-mcp": ("http://unifi-mcp.cortex-system.svc.cluster.local:3000/health", "mcp"),
            # Cortex Fabric
            "fabric-gateway": ("http://cortex-fabric-gateway.cortex-system.svc.cluster.local:8080/health", "fabric"),
            "fabric-bridge": ("http://cortex-bridge.cortex-system.svc.cluster.local:8080/health", "fabric"),
            # Infrastructure
            "orchestrator": (f"{ORCHESTRATOR_URL}/health", "infrastructure"),
            "qdrant": ("http://qdrant.cortex-chat.svc.cluster.local:6333/readyz", "infrastructure"),
            "redis": ("http://redis.cortex-system.svc.cluster.local:6379", "infrastructure"),
        }

        results = {
            "mcp_servers": [],
            "cortex_fabric": [],
            "infrastructure": [],
            "mcp_call": {"status": "unknown", "last_call": None}
        }

        # Check services in parallel
        with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
            future_to_service = {
                executor.submit(check_service, name, url): (name, category)
                for name, (url, category) in services.items()
            }

            for future in concurrent.futures.as_completed(future_to_service):
                name, category = future_to_service[future]
                result = future.result()

                if category == "mcp":
                    results["mcp_servers"].append(result)
                elif category == "fabric":
                    results["cortex_fabric"].append(result)
                elif category == "infrastructure":
                    results["infrastructure"].append(result)

        # Determine overall status for each category
        def get_overall_status(items):
            if not items:
                return "unknown"
            statuses = [item["status"] for item in items]
            if all(s == "connected" for s in statuses):
                return "healthy"
            elif any(s == "connected" for s in statuses):
                return "degraded"
            else:
                return "offline"

        results["overall"] = {
            "mcp_servers": get_overall_status(results["mcp_servers"]),
            "cortex_fabric": get_overall_status(results["cortex_fabric"]),
            "infrastructure": get_overall_status(results["infrastructure"])
        }

        results["timestamp"] = datetime.utcnow().isoformat()

        return jsonify(results), 200

    # Service to Kubernetes deployment mapping
    SERVICE_DEPLOYMENTS = {
        # MCP Servers
        "cortex-mcp": {"namespace": "cortex-system", "deployment": "cortex-mcp-server"},
        "sandfly-mcp": {"namespace": "cortex-system", "deployment": "sandfly-mcp-server"},
        "proxmox-mcp": {"namespace": "cortex-system", "deployment": "proxmox-mcp-server"},
        "unifi-mcp": {"namespace": "cortex-system", "deployment": "unifi-mcp-server"},
        # Cortex Fabric
        "fabric-gateway": {"namespace": "cortex-system", "deployment": "fabric-gateway"},
        "fabric-bridge": {"namespace": "cortex-system", "deployment": "cortex-bridge"},
        # Infrastructure
        "orchestrator": {"namespace": "cortex-system", "deployment": "cortex-orchestrator"},
        "qdrant": {"namespace": "cortex-chat", "deployment": "qdrant"},
        "redis": {"namespace": "cortex-system", "deployment": "redis"},
    }

    def restart_deployment(namespace, deployment_name):
        """Restart a deployment using Kubernetes API via HTTP"""
        try:
            # Read service account token
            with open('/var/run/secrets/kubernetes.io/serviceaccount/token', 'r') as f:
                token = f.read().strip()

            # Read CA cert path
            ca_cert = '/var/run/secrets/kubernetes.io/serviceaccount/ca.crt'

            # Kubernetes API server
            api_server = 'https://kubernetes.default.svc'

            # Patch body to trigger rolling restart
            patch_body = {
                "spec": {
                    "template": {
                        "metadata": {
                            "annotations": {
                                "kubectl.kubernetes.io/restartedAt": datetime.utcnow().isoformat()
                            }
                        }
                    }
                }
            }

            url = f"{api_server}/apis/apps/v1/namespaces/{namespace}/deployments/{deployment_name}"

            response = requests.patch(
                url,
                json=patch_body,
                headers={
                    'Authorization': f'Bearer {token}',
                    'Content-Type': 'application/strategic-merge-patch+json'
                },
                verify=ca_cert,
                timeout=10
            )

            if response.status_code in [200, 201]:
                return True, None
            else:
                return False, f"API returned {response.status_code}: {response.text[:200]}"

        except FileNotFoundError:
            return False, "Service account token not found - not running in cluster"
        except Exception as e:
            return False, str(e)

    @app.route('/api/restart', methods=['POST'])
    def restart_services():
        """Restart unhealthy services via Kubernetes API"""
        data = request.json or {}
        services = data.get('services', [])
        restart_all_unhealthy = data.get('restart_all_unhealthy', False)

        # If restart_all_unhealthy, first get status and find unhealthy services
        if restart_all_unhealthy:
            # Get current status
            status_response = get_system_status()
            status_data = status_response[0].get_json()

            services = []
            for category in ['mcp_servers', 'cortex_fabric', 'infrastructure']:
                for item in status_data.get(category, []):
                    if item.get('status') != 'connected':
                        services.append(item.get('name'))

        if not services:
            return jsonify({"message": "No services to restart", "restarted": []}), 200

        results = {"restarted": [], "failed": [], "skipped": []}

        for service_name in services:
            if service_name not in SERVICE_DEPLOYMENTS:
                results["skipped"].append({"name": service_name, "reason": "Unknown service"})
                continue

            deployment_info = SERVICE_DEPLOYMENTS[service_name]
            namespace = deployment_info["namespace"]
            deployment = deployment_info["deployment"]

            success, error = restart_deployment(namespace, deployment)

            if success:
                results["restarted"].append({
                    "name": service_name,
                    "deployment": deployment,
                    "namespace": namespace
                })
                logger.info(f"Restarted {deployment} in {namespace}")
            else:
                results["failed"].append({
                    "name": service_name,
                    "error": error
                })
                logger.error(f"Failed to restart {deployment}: {error}")

        return jsonify(results), 200

    @app.route('/api/restart/<service_name>', methods=['POST'])
    def restart_single_service(service_name):
        """Restart a single service by name"""
        if service_name not in SERVICE_DEPLOYMENTS:
            return jsonify({"error": f"Unknown service: {service_name}"}), 404

        deployment_info = SERVICE_DEPLOYMENTS[service_name]
        namespace = deployment_info["namespace"]
        deployment = deployment_info["deployment"]

        success, error = restart_deployment(namespace, deployment)

        if success:
            return jsonify({
                "restarted": [{
                    "name": service_name,
                    "deployment": deployment,
                    "namespace": namespace
                }],
                "failed": [],
                "skipped": []
            }), 200
        else:
            return jsonify({
                "restarted": [],
                "failed": [{"name": service_name, "error": error}],
                "skipped": []
            }), 500

    if __name__ == '__main__':
        logger.info(f"Starting MoE Chat Router - routing to {ORCHESTRATOR_URL}")
        app.run(host='0.0.0.0', port=8080, debug=True)
  chat-router.py: |
    #!/usr/bin/env python3
    """
    MoE Chat Router - Routes to cortex-orchestrator with MCP server access
    Provides infrastructure management capabilities
    """
    import os
    import json
    import logging
    import requests
    from flask import Flask, request, jsonify
    from anthropic import Anthropic
    from datetime import datetime

    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    logger = logging.getLogger(__name__)

    app = Flask(__name__)

    # Initialize Anthropic client for intent classification
    anthropic_client = Anthropic(api_key=os.getenv('ANTHROPIC_API_KEY'))

    # Expert configuration - all route to cortex-orchestrator
    ORCHESTRATOR_URL = os.getenv('ORCHESTRATOR_URL', 'http://cortex-orchestrator.cortex-system.svc.cluster.local:8080')

    # Simple in-memory conversation storage
    conversations = {}

    @app.route('/health', methods=['GET'])
    def health():
        return jsonify({"status": "healthy", "service": "moe-chat-router"}), 200

    @app.route('/api/auth/login', methods=['POST'])
    def login():
        """Auth endpoint"""
        data = request.json or {}
        username = data.get('username', 'user')
        return jsonify({
            "success": True,
            "token": "mock-token-123",
            "username": username,
            "user": {"username": username, "id": "user-1"}
        }), 200

    @app.route('/api/conversations', methods=['GET'])
    def get_conversations():
        """Get all conversations"""
        conv_list = [
            {
                "id": conv_id,
                "title": f"Conversation {conv_id[:30]}..." if len(conv_id) > 30 else f"Conversation {conv_id}",
                "lastMessage": msgs[-1]["content"] if msgs else "No messages",
                "timestamp": "2026-01-19T00:00:00Z",
                "messageCount": len(msgs)
            }
            for conv_id, msgs in conversations.items()
        ]
        return jsonify(conv_list), 200

    @app.route('/api/conversations', methods=['POST'])
    def create_conversation():
        """Create new conversation"""
        conv_id = f"conv-{len(conversations) + 1}"
        conversations[conv_id] = []
        return jsonify({"id": conv_id, "title": f"New Conversation {conv_id}"}), 201

    @app.route('/api/chat', methods=['POST'])
    def chat():
        """Main chat endpoint - routes to cortex-orchestrator"""
        try:
            data = request.json
            message = data.get('message', '')
            conversation_id = data.get('sessionId', 'default')

            logger.info(f"Chat request: conversation={conversation_id}, message={message[:50]}...")

            # Store user message
            if conversation_id not in conversations:
                conversations[conversation_id] = []
            conversations[conversation_id].append({
                "role": "user",
                "content": message
            })

            # Classify intent
            intent_prompt = f"""Classify this user message into one of these categories:
            - infrastructure: Kubernetes, pods, deployments, nodes, services
            - security: Sandfly alerts, vulnerabilities, security events
            - automation: n8n workflows, task automation
            - general: Everything else

            User message: {message}

            Respond with just the category name."""

            try:
                intent_response = anthropic_client.messages.create(
                    model="claude-3-5-haiku-20241022",
                    max_tokens=10,
                    messages=[{"role": "user", "content": intent_prompt}]
                )
                expert = intent_response.content[0].text.strip().lower()
                if expert not in ['infrastructure', 'security', 'automation', 'general']:
                    expert = 'general'
            except Exception as e:
                logger.error(f"Intent classification error: {e}")
                expert = 'general'

            logger.info(f"Classified as: {expert}")

            # Route to cortex-orchestrator
            try:
                orch_request = {
                    "message": message,
                    "conversation_id": conversation_id,
                    "expert": expert,
                    "history": conversations[conversation_id][:-1]  # Exclude the message we just added
                }

                response = requests.post(
                    f"{ORCHESTRATOR_URL}/chat",
                    json=orch_request,
                    timeout=60
                )

                if response.status_code == 200:
                    assistant_message = response.json().get('response', 'No response from orchestrator')
                else:
                    logger.error(f"Orchestrator returned {response.status_code}: {response.text}")
                    assistant_message = f"The orchestrator is currently unavailable. Status: {response.status_code}"

            except requests.exceptions.Timeout:
                logger.error("Orchestrator timeout")
                assistant_message = "The request timed out. Please try again."
            except Exception as e:
                logger.error(f"Orchestrator routing error: {e}")
                assistant_message = f"Error routing to expert: {str(e)}"

            # Store assistant response
            conversations[conversation_id].append({
                "role": "assistant",
                "content": assistant_message
            })

            return jsonify({
                "response": assistant_message,
                "conversation_id": conversation_id,
                "expert": expert,
                "timestamp": datetime.utcnow().isoformat()
            }), 200

        except Exception as e:
            logger.error(f"Chat error: {e}")
            return jsonify({"error": str(e)}), 500

    @app.route('/api/conversations/<conversation_id>', methods=['GET'])
    def get_conversation(conversation_id):
        """Get conversation with messages"""
        if conversation_id not in conversations:
            conversations[conversation_id] = []

        messages = [
            {
                "role": msg["role"],
                "content": msg["content"],
                "timestamp": "2026-01-19T00:00:00Z"
            }
            for msg in conversations[conversation_id]
        ]

        return jsonify({
            "conversation": {
                "id": conversation_id,
                "title": f"Conversation {conversation_id[:30]}..." if len(conversation_id) > 30 else f"Conversation {conversation_id}",
                "timestamp": "2026-01-19T00:00:00Z",
                "messageCount": len(messages),
                "messages": messages
            }
        }), 200

    @app.route('/api/conversations/<conversation_id>/messages', methods=['GET'])
    def get_messages(conversation_id):
        """Get conversation history"""
        if conversation_id not in conversations:
            return jsonify([]), 200

        messages = [
            {
                "role": msg["role"],
                "content": msg["content"],
                "timestamp": "2026-01-19T00:00:00Z"
            }
            for msg in conversations[conversation_id]
        ]
        return jsonify(messages), 200

    if __name__ == '__main__':
        logger.info(f"Starting MoE Chat Router - routing to {ORCHESTRATOR_URL}")
        app.run(host='0.0.0.0', port=8080, debug=True)
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: moe-router
  namespace: cortex-chat
  labels:
    app: moe-router
spec:
  replicas: 1
  selector:
    matchLabels:
      app: moe-router
  template:
    metadata:
      labels:
        app: moe-router
    spec:
      serviceAccountName: moe-router
      nodeSelector:
        kubernetes.io/hostname: k3s-worker04
      securityContext:
        fsGroup: 1000
        runAsNonRoot: true
        runAsUser: 1000
        seccompProfile:
          type: RuntimeDefault
      containers:
      - name: moe-router
        image: 10.43.170.72:5000/moe-router:latest
        imagePullPolicy: IfNotPresent
        command: ["python", "simple-chat-api.py"]
        ports:
        - containerPort: 8080
          name: http
          protocol: TCP
        env:
        - name: CONFIG_PATH
          value: /config/config.yaml
        - name: ANTHROPIC_API_KEY
          valueFrom:
            secretKeyRef:
              name: cortex-chat-secrets
              key: anthropic-api-key
        volumeMounts:
        - name: config
          mountPath: /config
        - name: code-fix
          mountPath: /app/simple-chat-api.py
          subPath: simple-chat-api.py
        resources:
          requests:
            cpu: 250m
            memory: 256Mi
          limits:
            cpu: 1000m
            memory: 512Mi
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 10
          periodSeconds: 5
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            drop:
            - ALL
          readOnlyRootFilesystem: true
      volumes:
      - name: config
        configMap:
          name: moe-router-config
      - name: code-fix
        configMap:
          name: moe-router-config
---
apiVersion: v1
kind: Service
metadata:
  name: moe-router
  namespace: cortex-chat
  labels:
    app: moe-router
spec:
  type: ClusterIP
  ports:
  - port: 8080
    targetPort: 8080
    protocol: TCP
    name: http
  selector:
    app: moe-router
