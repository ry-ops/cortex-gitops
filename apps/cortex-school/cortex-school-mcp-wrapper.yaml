apiVersion: v1
kind: ConfigMap
metadata:
  name: cortex-school-mcp-wrapper
  namespace: cortex-school
  labels:
    app: cortex-school-mcp
    component: mcp-wrapper
data:
  server.py: |
    #!/usr/bin/env python3
    """
    MCP Wrapper for Cortex School Service
    Exposes learning and content management capabilities as MCP tools
    """
    import os
    import json
    import logging
    import asyncio
    import httpx
    from typing import Any
    from mcp.server import Server
    from mcp.types import Tool, TextContent
    from mcp.server.stdio import stdio_server

    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger(__name__)

    SCHOOL_COORDINATOR_URL = os.getenv('SCHOOL_COORDINATOR_URL', 'http://school-coordinator.cortex-school.svc.cluster.local:8080')
    RAG_VALIDATOR_URL = os.getenv('RAG_VALIDATOR_URL', 'http://rag-validator.cortex-school.svc.cluster.local:8080')
    BLOG_WRITER_URL = os.getenv('BLOG_WRITER_URL', 'http://blog-writer.cortex-school.svc.cluster.local:8080')
    TELEMETRY_ENABLED = os.getenv('TELEMETRY_ENABLED', 'true').lower() == 'true'

    app = Server("cortex-school-mcp")

    @app.list_tools()
    async def list_tools() -> list[Tool]:
        """List available Cortex School tools."""
        return [
            Tool(
                name="create_learning_module",
                description="Create a new learning module from ingested content",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "title": {"type": "string", "description": "Module title"},
                        "source_videos": {"type": "array", "items": {"type": "string"}, "description": "Video IDs to use as source"},
                        "difficulty": {"type": "string", "enum": ["beginner", "intermediate", "advanced"], "description": "Difficulty level"},
                        "tags": {"type": "array", "items": {"type": "string"}, "description": "Content tags"}
                    },
                    "required": ["title", "source_videos"]
                }
            ),
            Tool(
                name="generate_quiz",
                description="Generate a quiz from learning content",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "module_id": {"type": "string", "description": "Learning module ID"},
                        "num_questions": {"type": "integer", "description": "Number of questions", "default": 10},
                        "question_types": {"type": "array", "items": {"type": "string"}, "description": "Types: multiple_choice, true_false, short_answer"}
                    },
                    "required": ["module_id"]
                }
            ),
            Tool(
                name="validate_rag_content",
                description="Validate RAG-generated content for accuracy",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "content": {"type": "string", "description": "Content to validate"},
                        "source_references": {"type": "array", "items": {"type": "string"}, "description": "Source document IDs"}
                    },
                    "required": ["content"]
                }
            ),
            Tool(
                name="generate_blog_post",
                description="Generate a blog post from learning content",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "topic": {"type": "string", "description": "Blog topic"},
                        "source_modules": {"type": "array", "items": {"type": "string"}, "description": "Module IDs to reference"},
                        "style": {"type": "string", "enum": ["technical", "casual", "tutorial"], "default": "technical"},
                        "length": {"type": "string", "enum": ["short", "medium", "long"], "default": "medium"}
                    },
                    "required": ["topic"]
                }
            ),
            Tool(
                name="list_learning_modules",
                description="List available learning modules",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "category": {"type": "string", "description": "Filter by category"},
                        "difficulty": {"type": "string", "description": "Filter by difficulty"},
                        "limit": {"type": "integer", "default": 20}
                    }
                }
            ),
            Tool(
                name="get_learning_progress",
                description="Get learning progress statistics",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "user_id": {"type": "string", "description": "User ID (optional)"},
                        "module_id": {"type": "string", "description": "Module ID (optional)"}
                    }
                }
            ),
            Tool(
                name="search_knowledge_base",
                description="Search the school knowledge base",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "query": {"type": "string", "description": "Search query"},
                        "filters": {"type": "object", "description": "Search filters"},
                        "limit": {"type": "integer", "default": 10}
                    },
                    "required": ["query"]
                }
            )
        ]

    @app.call_tool()
    async def call_tool(name: str, arguments: dict[str, Any]) -> list[TextContent]:
        """Execute Cortex School tools."""
        logger.info(f"Calling tool: {name} with args: {arguments}")

        try:
            async with httpx.AsyncClient(timeout=120.0) as client:
                # Route to appropriate service
                if name in ["create_learning_module", "list_learning_modules", "get_learning_progress", "generate_quiz"]:
                    base_url = SCHOOL_COORDINATOR_URL
                elif name == "validate_rag_content":
                    base_url = RAG_VALIDATOR_URL
                elif name == "generate_blog_post":
                    base_url = BLOG_WRITER_URL
                elif name == "search_knowledge_base":
                    base_url = SCHOOL_COORDINATOR_URL
                else:
                    return [TextContent(type="text", text=f"Unknown tool: {name}")]

                # Map tool to endpoint
                endpoint_map = {
                    "create_learning_module": "/api/modules",
                    "generate_quiz": "/api/quizzes/generate",
                    "validate_rag_content": "/api/validate",
                    "generate_blog_post": "/api/blog/generate",
                    "list_learning_modules": "/api/modules",
                    "get_learning_progress": "/api/progress",
                    "search_knowledge_base": "/api/search"
                }

                endpoint = endpoint_map.get(name, f"/api/{name}")

                if name in ["list_learning_modules", "get_learning_progress"]:
                    response = await client.get(f"{base_url}{endpoint}", params=arguments)
                else:
                    response = await client.post(f"{base_url}{endpoint}", json=arguments)

                result = response.json() if response.status_code in [200, 201] else {"error": response.text, "status": response.status_code}

                if TELEMETRY_ENABLED:
                    logger.info(f"Telemetry: tool={name}, status={response.status_code}")

                return [TextContent(type="text", text=json.dumps(result, indent=2))]

        except Exception as e:
            logger.error(f"Tool error: {e}")
            return [TextContent(type="text", text=f"Error: {str(e)}")]

    async def main():
        async with stdio_server() as (read_stream, write_stream):
            await app.run(read_stream, write_stream, app.create_initialization_options())

    if __name__ == "__main__":
        asyncio.run(main())

  sse-wrapper.py: |
    #!/usr/bin/env python3
    """SSE/HTTP wrapper for MCP server."""
    import os
    import json
    import subprocess
    import uuid
    from flask import Flask, request, Response, jsonify

    app = Flask(__name__)
    PORT = int(os.getenv('PORT', '3000'))
    MCP_SCRIPT = os.getenv('MCP_SCRIPT', '/app/server.py')

    sessions = {}

    @app.route('/health', methods=['GET'])
    def health():
        return jsonify({"status": "healthy", "service": "cortex-school-mcp"})

    @app.route('/sse', methods=['GET'])
    def sse():
        session_id = str(uuid.uuid4())

        def generate():
            proc = subprocess.Popen(
                ['python3', MCP_SCRIPT],
                stdin=subprocess.PIPE,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
            sessions[session_id] = proc

            try:
                for line in proc.stdout:
                    yield f"data: {line}\n\n"
            finally:
                proc.terminate()
                sessions.pop(session_id, None)

        return Response(generate(), mimetype='text/event-stream')

    @app.route('/message', methods=['POST'])
    def message():
        data = request.json
        session_id = data.get('session_id')
        message = data.get('message')

        if session_id in sessions:
            proc = sessions[session_id]
            proc.stdin.write(json.dumps(message) + '\n')
            proc.stdin.flush()
            return jsonify({"status": "sent"})

        return jsonify({"error": "session not found"}), 404

    if __name__ == '__main__':
        app.run(host='0.0.0.0', port=PORT)
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: cortex-school-mcp
  namespace: cortex-school
  labels:
    app: cortex-school-mcp
    component: mcp-server
spec:
  replicas: 1
  selector:
    matchLabels:
      app: cortex-school-mcp
  template:
    metadata:
      labels:
        app: cortex-school-mcp
        component: mcp-server
    spec:
      containers:
      - name: mcp-server
        image: python:3.11-slim
        command:
        - /bin/sh
        - -c
        - |
          pip install -q flask mcp httpx pydantic
          cd /app
          python3 sse-wrapper.py
        ports:
        - containerPort: 3000
          name: mcp
        env:
        - name: SCHOOL_COORDINATOR_URL
          value: "http://school-coordinator.cortex-school.svc.cluster.local:8080"
        - name: RAG_VALIDATOR_URL
          value: "http://rag-validator.cortex-school.svc.cluster.local:8080"
        - name: BLOG_WRITER_URL
          value: "http://blog-writer.cortex-school.svc.cluster.local:8080"
        - name: TELEMETRY_ENABLED
          value: "true"
        - name: PORT
          value: "3000"
        - name: MCP_SCRIPT
          value: "/app/server.py"
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 500m
            memory: 512Mi
        volumeMounts:
        - name: mcp-code
          mountPath: /app/server.py
          subPath: server.py
        - name: mcp-code
          mountPath: /app/sse-wrapper.py
          subPath: sse-wrapper.py
        readinessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 10
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 60
          periodSeconds: 30
      volumes:
      - name: mcp-code
        configMap:
          name: cortex-school-mcp-wrapper
---
apiVersion: v1
kind: Service
metadata:
  name: cortex-school-mcp
  namespace: cortex-school
  labels:
    app: cortex-school-mcp
spec:
  selector:
    app: cortex-school-mcp
  ports:
  - port: 3000
    targetPort: 3000
    name: mcp
  type: ClusterIP
